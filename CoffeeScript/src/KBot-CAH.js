// Generated by CoffeeScript 1.8.0
(function() {
  KBot.Cah.users = [];
  KBot.Cah.hands = [];
  KBot.Cah.Round = {
    number: NaN,
    phase: "select",
    hands: [],
    card: null,
    judge: 0,
    channel: null
  };
  KBot.Cah.used = [];
  KBot.Cah.inPlay = false;
  return KBot.Cah.print = function(msg, msgObj, qHandle) {
    if (KBot.waitFor && !qHandle) {
      return KBot.queue.push(function() {
        return KBot.Cah.print(msg, msgObj, true);
      });
    }
    KBot.waitFor = true;
    if (msgObj.to.type === "channel") {
      FList.Chat.printMessage({
        msg: "[b]K-CAH[/b]: " + msg,
        to: FList.Chat.TabBar.getTabFromId("channel", KBot.Cah.Round.channel),
        from: FList.Chat.identity,
        type: "chat"
      });
      return FList.Connection.send("MSG " + JSON.stringify({
        "channel": KBot.Cah.Round.channel,
        "message": "[b]K-CAH[/b]: " + msg
      }));
    } else {
      return FList.Connection.send("PRI " + JSON.stringify({
        "recipient": msgObj.to.id,
        "message": "[b]K-CAH[/b]: " + msg
      }));
    }
  };
})();

KBot.Cmds.cah = (function() {
  var BLACK_CARDS, Cah, Chat, Cmd, Hands, Phase, Round, Users, WHITE_CARDS, cah, createHand, funcs, gameInit, getPlayers, newRound, select;
  Cmd = KBot.Cmds;
  Cah = KBot.Cah;
  Users = Cah.users;
  Round = Cah.Round;
  Phase = Round.phase;
  Hands = Round.hands;
  Chat = FList.Chat;
  BLACK_CARDS = Cah.Cards.BLACK_CARDS;
  WHITE_CARDS = Cah.Cards.WHITE_CARDS;
  createHand = function(player) {
    var card, msgObj, n, person, sendString, user, _i, _j, _len, _len1, _ref;
    msgObj = {
      to: {
        id: player,
        type: "user"
      }
    };
    sendString = "Your hand for this round is:\n";
    for (_i = 0, _len = Users.length; _i < _len; _i++) {
      user = Users[_i];
      if (user.name === player) {
        person = user;
        break;
      }
    }
    while (person.hand.length < 8) {
      card = WHITE_CARDS[~~(Math.random() * WHITE_CARDS.length)];
      while (Cah.used.indexOf(card) !== -1) {
        card = WHITE_CARDS[~~(Math.random() * WHITE_CARDS.length)];
      }
    }
    person.hand.push(card);
    Cah.used.push(card);
    _ref = person.hand;
    for (n = _j = 0, _len1 = _ref.length; _j < _len1; n = ++_j) {
      card = _ref[n];
      sendString += "" + n + ") " + card + "\n";
    }
    return Cah.print(sendString, msgObj);
  };
  newRound = function() {
    var black, card, key, msgObj, n, sendString, user, _i, _j, _len, _len1, _ref;
    Round.phase = "select";
    Round.number++;
    Round.judge++;
    Round.judge = Round.judge === Users.length ? 0 : Round.judge;
    Round.hands = [];
    for (key = _i = 0, _len = Users.length; _i < _len; key = ++_i) {
      user = Users[key];
      sendString = "Your hand for this round is:\n";
      while (user.hand.length < 8) {
        card = WHITE_CARDS[~~(Math.random() * WHITE_CARDS.length)];
        while (Cah.used.indexOf(card) !== -1) {
          card = WHITE_CARDS[~~(Math.random() * WHITE_CARDS.length)];
        }
        user.hand.push(card);
        Cah.used.push(card);
      }
      _ref = user.hand;
      for (n = _j = 0, _len1 = _ref.length; _j < _len1; n = ++_j) {
        card = _ref[n];
        sendString += "" + n + ") " + card + "\n";
      }
      if (key === Round.judge) {
        sendString += "\n[b]You are the current judge.[/b]";
      }
      msgObj = {
        to: {
          id: user.name,
          type: "user"
        }
      };
      Cah.print(sendString, msgObj);
    }
    black = BLACK_CARDS[~~(Math.random() * BLACK_CARDS.length)];
    Round.card = {
      text: black.card,
      pick: black.pick
    };
    msgObj = {
      to: {
        type: "channel"
      }
    };
    return Cah.print(("Judge: " + Users[Round.judge].name + "\nRound [b]" + Round.number + "[/b]\n") + ("Pick: " + Round.card.pick + "\n") + ("Black Card: " + Round.card.text), msgObj);
  };
  gameInit = function() {
    var black, card, key, msgObj, n, sendString, user, _i, _j, _len;
    Cah.used = [];
    for (key = _i = 0, _len = Users.length; _i < _len; key = ++_i) {
      user = Users[key];
      user.hand = [];
      sendString = "Your hand for this round is:\n";
      for (n = _j = 0; _j < 8; n = ++_j) {
        card = WHITE_CARDS[~~(Math.random() * WHITE_CARDS.length)];
        while (Cah.used.indexOf(card) !== -1) {
          card = WHITE_CARDS[~~(Math.random() * WHITE_CARDS.length)];
        }
        Cah.used.push(card);
        user.hand.push(card);
        sendString += "" + n + ") " + card + "\n";
      }
      sendString = sendString.slice(0, sendString.length - 1);
      if (key === Round.judge) {
        sendString += "\n[b]You are the current judge.[/b]";
      }
      msgObj = {
        to: {
          id: user.name,
          type: "user"
        }
      };
      Cah.print(sendString, msgObj);
    }
    black = BLACK_CARDS[~~(Math.random() * BLACK_CARDS.length)];
    Round.card = {
      text: black.card,
      pick: black.pick
    };
    msgObj = {
      to: {
        type: "channel"
      }
    };
    return Cah.print(("Judge: " + Users[Round.judge].name + "\nPick: " + Round.card.pick + "\n") + ("Black Card: " + Round.card.text), msgObj);
  };
  getPlayers = function() {
    var pObj, players, _i, _len;
    players = [];
    for (_i = 0, _len = Users.length; _i < _len; _i++) {
      pObj = Users[_i];
      players.push(pObj.name);
    }
    return players;
  };
  select = function(cards, player) {
    var card, hand, isJudge, isValid, key, msg, msgObj, pObj, user, val, winner, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _m, _n, _ref, _ref1, _ref2;
    isValid = false;
    isJudge = false;
    msgObj = {
      to: {
        type: "channel"
      }
    };
    for (_i = 0, _len = Users.length; _i < _len; _i++) {
      user = Users[_i];
      if (user.name === player) {
        pObj = user;
        isValid = true;
        isJudge = Users[Round.judge].name === player;
        break;
      }
    }
    if (isJudge && Round.phase === "judge") {
      if (!Round.hands[cards[0]]) {
        return Cah.print("You cannot select a hand that doesn't exist.", msgObj);
      }
      for (_j = 0, _len1 = Users.length; _j < _len1; _j++) {
        user = Users[_j];
        if (user.name === Round.hands[cards[0]].name) {
          winner = user;
        }
      }
      winner.score += 1;
      Cah.print(("" + winner.name + " has won the round and has a total") + (" of [b]" + winner.score + "[/b] points."), msgObj);
      return newRound();
    }
    if (Round.phase === "select" && isJudge) {
      return Cah.print("You are this round's judge.", msgObj);
    }
    if (Round.phase === "judge") {
      return Cah.print("You are not the judge.", msgObj);
    }
    if (!isValid) {
      return Cah.print("Cannot select when not in game.", msgObj);
    }
    if (Phase === "judge") {
      return Cah.print("Cannot select within judgement phase.", msgObj);
    }
    if (!Cah.inPlay) {
      return Cah.print("Cannot select when a game is not active.", msgObj);
    }
    _ref = Round.hands;
    for (_k = 0, _len2 = _ref.length; _k < _len2; _k++) {
      hand = _ref[_k];
      if (hand.name === player) {
        return Cah.print("You have already submitted your hand.", msgObj);
      }
    }
    if (cards.length !== Round.card.pick) {
      return Cah.print("Invalid card selection where the current card's pick number " + ("is " + Round.card.pick + " and you selected " + cards.length + "."), msgObj);
    }
    hand = {
      name: player,
      cards: []
    };
    for (val = _l = 0, _len3 = cards.length; _l < _len3; val = ++_l) {
      card = cards[val];
      if (!pObj.hand[card]) {
        return Cah.print("Invalid selection: " + val + ".", msgObj);
      }
      hand.cards.push(pObj.hand[card]);
    }
    _ref1 = hand.cards;
    for (val = _m = 0, _len4 = _ref1.length; _m < _len4; val = ++_m) {
      card = _ref1[val];
      pObj.hand.splice(pObj.hand.indexOf(card), 1);
      Cah.used.splice(Cah.used.indexOf(card), 1);
    }
    Round.hands.push(hand);
    console.log(Round.hands, hand);
    Cah.print("" + player + " has submitted their hand.", msgObj);
    if (Round.hands.length === Users.length - 1) {
      Round.phase = "judge";
      msg = "" + Users[Round.judge].name + " please select a card combo:\n";
      Round.hands = Round.hands.sort(function() {
        return ~~(Math.random() * 2);
      });
      _ref2 = Round.hands;
      for (key = _n = 0, _len5 = _ref2.length; _n < _len5; key = ++_n) {
        hand = _ref2[key];
        msg += "" + key + ") " + (hand.cards.join(", ")) + "\n";
      }
      msg = msg.slice(0, msg.length - 1);
      return Cah.print(msg, msgObj);
    }
  };
  funcs = {
    quit: function(x, player, msgObj) {
      var card, hand, key, msg, uKey, user, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2;
      for (key = _i = 0, _len = Users.length; _i < _len; key = ++_i) {
        user = Users[key];
        if (user.name === player) {
          uKey = key;
          break;
        }
      }
      msgObj = {
        to: {
          type: "channel"
        }
      };
      _ref = Users[uKey].hand;
      for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
        card = _ref[_j];
        Cah.used.splice(Cah.used.indexOf(card), 1);
      }
      Users.splice(uKey, 1);
      if (!Cah.inPlay) {
        return Cah.print("" + player + " has left the game.", msgObj);
      }
      if (Users.length < 3 && Cah.inPlay) {
        Cah.inPlay = false;
        Cah.used = [];
        Round.judge = 0;
        Round.number = 0;
        Round.card = null;
        Round.channel = null;
        return Cah.print(("" + player + " has left the game. Game cannot continue with ") + "less than 3 players. Reseting.", msgObj);
      }
      if (Round.phase = "judge" && Round.judge === uKey) {
        Cah.print(("" + player + " has left the game, and due to being the judge, the ") + "round must be reset.", msgObj);
        return newRound();
      }
      Cah.print("" + player + " has left the game.", msgObj);
      _ref1 = Round.hands;
      for (key = _k = 0, _len2 = _ref1.length; _k < _len2; key = ++_k) {
        hand = _ref1[key];
        if (hand.name === player) {
          Round.hands.splice(key, 1);
          break;
        }
      }
      if (Round.hands.length === Users.length) {
        Round.phase = "judge";
        msg = "" + Users[Round.judge].name + " please select a card combo:\n";
        Round.hands = Round.hands.sort(function() {
          return ~~(Math.random() * 2);
        });
        _ref2 = Round.hands;
        for (key = _l = 0, _len3 = _ref2.length; _l < _len3; key = ++_l) {
          hand = _ref2[key];
          msg += "" + key + ") " + (hand.hand.join(", ")) + "\n";
        }
        msg = msg.slice(0, msg.length - 1);
        return Cah.print(msg, msgObj);
      }
    },
    join: function(x, player, msgObj) {
      var pObj, user, _i, _len;
      for (_i = 0, _len = Users.length; _i < _len; _i++) {
        user = Users[_i];
        if (user.name === player) {
          return Cah.print("You are already in the game.", msgObj);
        }
      }
      pObj = {
        name: player,
        score: 0,
        hand: []
      };
      Cah.users.push(pObj);
      Round.channel = msgObj.to.id;
      if (Cah.inPlay) {
        createHand(player);
        return Cah.print("" + player + " has joined the game in progress.", msgObj);
      }
      return Cah.print(("" + player + " has joined the game. Current players waiting to ") + ("play: " + (getPlayers().join(", "))), msgObj);
    },
    start: function(x, y, msgObj) {
      if (!(Users.length > 2)) {
        return Cah.print("You require at least three players to begin a game.", "play: " + (getPlayers().join(", ")), msgObj);
      }
      Cah.print("ROUND 1, FIGHT!", msgObj);
      Round.judge = ~~(Math.random() * Users.length);
      Round.number = 1;
      Round.phase = "select";
      Cah.inPlay = true;
      return gameInit(msgObj);
    }
  };
  cah = function(msg, msgObj) {
    var card, cmd, key, _i, _len;
    msg = msg.trim().replace(new RegExp("/ +/", "g"));
    cmd = msg.split(" ")[0];
    if (msg.split(",").length > 1) {
      msg = msg.split(",");
      for (key = _i = 0, _len = msg.length; _i < _len; key = ++_i) {
        card = msg[key];
        msg[key] = parseInt(card, 10);
      }
      select(msg, msgObj.from, msgObj);
      return;
    }
    if (!isNaN(parseInt(msg))) {
      msg = [parseInt(msg, 10)];
      select(msg, msgObj.from);
      return;
    }
    if (!funcs[cmd]) {
      return Cah.print("Wat?", msgObj);
    }
    funcs[cmd](msg, msgObj.from, msgObj);
  };
  return cah;
})();
